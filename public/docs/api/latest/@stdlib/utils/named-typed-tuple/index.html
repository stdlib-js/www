<h1 id="named-typed-tuple">Named Typed Tuple</h1><blockquote><p>Create a factory for generating named typed tuples.</p></blockquote><section class="intro"><p>Named tuples assign a property name, and thus a meaning, to each position in a tuple and allow for more readable, self-documenting code.</p><p>Named typed tuples can be used wherever <a href="/docs/api/latest/@stdlib/array/typed">typed arrays</a> are used, with the added benefit that they allow accessing fields by both field name and position index.</p></section><section class="usage"><h2 id="usage">Usage</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> namedtypedtuple = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/utils/named-typed-tuple'</span> );
</code></pre><p><a name="main"></a></p><h4 id="namedtypedtuple-fields-options-">namedtypedtuple( fields[, options] )</h4><p>Returns a named typed tuple factory.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>The function accepts the following <code>options</code>:</p><ul><li><p><strong>dtype</strong>: default tuple data type. If a data type is not provided to a named typed tuple factory, this option specifies the underlying tuple data type. The following data types are supported:</p><ul><li><code>float64</code>: double-precision floating-point numbers (IEEE 754).</li><li><code>float32</code>: single-precision floating-point numbers (IEEE 754).</li><li><code>int32</code>: 32-bit two's complement signed integers.</li><li><code>uint32</code>: 32-bit unsigned integers.</li><li><code>int16</code>: 16-bit two's complement signed integers.</li><li><code>uint16</code>: 16-bit unsigned integers.</li><li><code>int8</code>: 8-bit two's complement signed integers.</li><li><code>uint8</code>: 8-bit unsigned integers.</li><li><code>uint8c</code>: 8-bit unsigned integers clamped to 0-255.</li></ul><p>Default: <code>'float64'</code>.</p></li><li><p><strong>name</strong>: tuple name. Default: <code>'tuple'</code>.</p></li></ul><hr><h3 id="tuple-factory">Tuple Factory</h3><p><a name="factory"></a></p><h4 id="factory">factory()</h4><p>Returns a named typed tuple of the default data type.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory();

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>
</code></pre><h4 id="factory-dtype-">factory( dtype )</h4><p>Returns a named typed tuple of the specified data type.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0</span>
</code></pre><h4 id="factory-typedarray-dtype-">factory( typedarray[, dtype] )</h4><p>Returns a named typed tuple from a <a href="/docs/api/latest/@stdlib/array/typed">typed array</a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] ) );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>To override the default tuple data type (and potentially cast <a href="/docs/api/latest/@stdlib/array/typed">typed array</a> values to another data type), provide a <code>dtype</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-comment">// Cast double-precision floating-point numbers to signed 32-bit integers:</span>
<span class="hljs-keyword">var</span> tuple = factory( <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] ), <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1</span>
</code></pre><h4 id="factory-obj-dtype-">factory( obj[, dtype] )</h4><p>Returns a named typed tuple from an array-like object or iterable.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>To override the default tuple data type, provide a <code>dtype</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1</span>
</code></pre><h4 id="factory-buffer-byteoffset-dtype-">factory( buffer[, byteOffset][, dtype] )</h4><p>Returns a named typed tuple view of an <a href="/docs/api/latest/@stdlib/array/buffer"><code>ArrayBuffer</code></a> where the view length equals the number of tuple fields.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">ArrayBuffer</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/buffer'</span> );

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>( <span class="hljs-number">32</span> );

<span class="hljs-comment">// Create a tuple view of the first 16 bytes (8 bytes per double):</span>
<span class="hljs-keyword">var</span> tuple = factory( buf );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Create a tuple view of the last 16 bytes:</span>
tuple = factory( buf, <span class="hljs-number">16</span> );

x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p>To override the default tuple data type, provide a <code>dtype</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">ArrayBuffer</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/buffer'</span> );

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>( <span class="hljs-number">16</span> );

<span class="hljs-comment">// Create a tuple view of the first 8 bytes (4 bytes per float):</span>
<span class="hljs-keyword">var</span> tuple = factory( buf, <span class="hljs-string">'float32'</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Create a tuple view of the last 8 bytes:</span>
tuple = factory( buf, <span class="hljs-number">8</span>, <span class="hljs-string">'float32'</span> );

x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 0.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p><a name="static-method-from"></a></p><h4 id="factoryfrom-src-map-thisarg-">factory.from( src[, map[, thisArg]] )</h4><p>Creates a new named typed tuple from an array-like <code>object</code> or an iterable.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory.from( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>To invoke a function for each <code>src</code> value, provide a callback function.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapFcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> tuple = factory.from( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ], mapFcn );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -2.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -2.0</span>
</code></pre><p>A callback function is provided three arguments:</p><ul><li><code>value</code>: source value.</li><li><code>index</code>: source index.</li><li><code>field</code>: tuple field.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapFcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> tuple = factory.from( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ], mapFcn, ctx );

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 2</span>
</code></pre><p><a name="static-method-from-object"></a></p><h4 id="factoryfromobject-obj-map-thisarg-">factory.fromObject( obj[, map[, thisArg]] )</h4><p>Creates a new named typed tuple from an <code>object</code> containing tuple fields.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-string">'x'</span>: <span class="hljs-number">1.0</span>,
    <span class="hljs-string">'y'</span>: -<span class="hljs-number">1.0</span>
};

<span class="hljs-keyword">var</span> tuple = factory.fromObject( obj );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>To invoke a function for each <code>src</code> object tuple field, provide a callback function.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapFcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-string">'x'</span>: <span class="hljs-number">1.0</span>,
    <span class="hljs-string">'y'</span>: -<span class="hljs-number">1.0</span>
};

<span class="hljs-keyword">var</span> tuple = factory.fromObject( obj, mapFcn );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -2.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -2.0</span>
</code></pre><p>A callback function is provided two arguments:</p><ul><li><code>value</code>: source object tuple field value.</li><li><code>field</code>: source object tuple field name.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapFcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-string">'x'</span>: <span class="hljs-number">1.0</span>,
    <span class="hljs-string">'y'</span>: -<span class="hljs-number">1.0</span>
};

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> tuple = factory.fromObject( obj, mapFcn, ctx );

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 2</span>
</code></pre><p><a name="static-method-of"></a></p><h4 id="factoryof-element0-element1-elementn-">factory.of( element0[, element1[, ...elementN]] )</h4><p>Creates a new named typed tuple from a variable number of arguments.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory.of( <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>
</code></pre><hr><h3 id="tuple">Tuple</h3><p><a name="prop-bytes-per-element"></a></p><h4 id="tuplebytes_per_element">tuple.BYTES_PER_ELEMENT</h4><p>Size (in bytes) of each tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> nbytes = tuple.BYTES_PER_ELEMENT;
<span class="hljs-comment">// returns 8</span>
</code></pre><p><a name="prop-buffer"></a></p><h4 id="tuplebuffer">tuple.buffer</h4><p>Pointer to the underlying data buffer.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> buf = tuple.buffer;
<span class="hljs-comment">// returns &#x3C;ArrayBuffer></span>
</code></pre><p><a name="prop-byte-length"></a></p><h4 id="tuplebytelength">tuple.byteLength</h4><p>Length (in bytes) of the tuple.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> nbytes = tuple.byteLength;
<span class="hljs-comment">// returns 16</span>
</code></pre><p><a name="prop-byte-offset"></a></p><h4 id="tuplebyteoffset">tuple.byteOffset</h4><p>Offset (in bytes) of a tuple from the start of its underlying <a href="/docs/api/latest/@stdlib/array/buffer"><code>ArrayBuffer</code></a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">ArrayBuffer</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/buffer'</span> );

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> offset = tuple.byteOffset;
<span class="hljs-comment">// returns 0</span>

<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>( <span class="hljs-number">64</span> );
tuple = factory( buf, <span class="hljs-number">32</span> );

offset = tuple.byteOffset;
<span class="hljs-comment">// returns 32</span>
</code></pre><p><a name="prop-length"></a></p><h4 id="tuplelength">tuple.length</h4><p>Number of tuple elements.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> len = tuple.length;
<span class="hljs-comment">// returns 2</span>
</code></pre><p><a name="prop-name"></a></p><h4 id="tuplename">tuple.name</h4><p>Tuple name.</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// Create a tuple factory which generates tuples having the default tuple name:</span>
<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> n = tuple.name;
<span class="hljs-comment">// returns 'tuple'</span>

<span class="hljs-comment">// Create a tuple factory which generates tuples having a custom tuple name:</span>
<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Point'</span>
};
factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ], opts );

tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

n = tuple.name;
<span class="hljs-comment">// returns 'Point'</span>
</code></pre><p><a name="prop-fields"></a></p><h4 id="tuplefields">tuple.fields</h4><p>Returns the list of tuple fields.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> fields = tuple.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>
</code></pre><p><a name="prop-ordered-fields"></a></p><h4 id="tupleorderedfields">tuple.orderedFields</h4><p>Returns the list of tuple fields in index order.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Sort tuple elements in ascending order:</span>
tuple.sort();

<span class="hljs-comment">// Get the list of tuple fields:</span>
<span class="hljs-keyword">var</span> fields = tuple.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>

<span class="hljs-comment">// Get the list of tuple fields in index order:</span>
fields = tuple.orderedFields;
<span class="hljs-comment">// returns [ 'y', 'x' ]</span>
</code></pre><p><a name="method-copy-within"></a></p><h4 id="tuplecopywithin-target-start-end-">tuple.copyWithin( target, start[, end] )</h4><p>Copies a sequence of elements within the tuple starting at <code>start</code> and ending at <code>end</code> (non-inclusive) to the position starting at <code>target</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -2.0</span>

<span class="hljs-comment">// Copy the last two elements to the first two elements:</span>
tuple.copyWithin( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );

x = tuple.x;
<span class="hljs-comment">// returns -1.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 1.0</span>
</code></pre><p>By default, <code>end</code> equals the number of tuple elements (i.e., one more than the last tuple index). To limit the sequence length, provide an <code>end</code> argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> w = tuple.w;
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> v = tuple.v;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-comment">// Copy the first two elements to the last two elements:</span>
tuple.copyWithin( <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );

w = tuple.w;
<span class="hljs-comment">// returns 2.0</span>

v = tuple.v;
<span class="hljs-comment">// returns -2.0</span>
</code></pre><p>When a <code>target</code>, <code>start</code>, and/or <code>end</code> index is negative, the respective index is determined relative to the last tuple element. The following example achieves the same behavior as the previous example:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> w = tuple.w;
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> v = tuple.v;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-comment">// Copy the first two elements to the last two elements:</span>
tuple.copyWithin( -<span class="hljs-number">2</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">3</span> );

w = tuple.w;
<span class="hljs-comment">// returns 2.0</span>

v = tuple.v;
<span class="hljs-comment">// returns -2.0</span>
</code></pre><p><a name="method-entries"></a></p><h4 id="tupleentries">tuple.entries()</h4><p>Returns an iterator for iterating over tuple key-value pairs.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Create an iterator:</span>
<span class="hljs-keyword">var</span> it = tuple.entries();

<span class="hljs-comment">// Iterate over key-value pairs...</span>
<span class="hljs-keyword">var</span> v = it.next().value;
<span class="hljs-comment">// returns [ 0, 'x', 1.0 ]</span>

v = it.next().value;
<span class="hljs-comment">// returns [ 1, 'y', -1.0 ]</span>

<span class="hljs-keyword">var</span> bool = it.next().done;
<span class="hljs-comment">// returns true</span>
</code></pre><p><a name="method-every"></a></p><h4 id="tupleevery-predicate-thisarg-">tuple.every( predicate[, thisArg] )</h4><p>Tests whether all tuple elements pass a test implemented by a <code>predicate</code> function.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v >= <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> bool = tuple.every( predicate );
<span class="hljs-comment">// returns false</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v >= <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> bool = tuple.every( predicate, ctx );
<span class="hljs-comment">// returns true</span>

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 2</span>
</code></pre><p><a name="method-field-of"></a></p><h4 id="tuplefieldof-searchelement-fromindex-">tuple.fieldOf( searchElement[, fromIndex] )</h4><p>Returns the field of the first tuple element strictly equal to a search element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.fieldOf( -<span class="hljs-number">1.0</span> );
<span class="hljs-comment">// returns 'z'</span>

field = tuple.fieldOf( <span class="hljs-number">2.0</span> );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>By default, the method searches the entire tuple (<code>fromIndex = 0</code>). To begin searching from a specific tuple index, provide a <code>fromIndex</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.fieldOf( <span class="hljs-number">1.0</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>When a <code>fromIndex</code> is negative, the starting index is resolved relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.fieldOf( <span class="hljs-number">1.0</span>, -<span class="hljs-number">2</span> );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>The method does <strong>not</strong> distinguish between signed and unsigned zero.</p><p><a name="method-fill"></a></p><h4 id="tuplefill-value-start-end-">tuple.fill( value[, start[, end]] )</h4><p>Fills a tuple from a <code>start</code> index to an <code>end</code> index (non-inclusive) with a provided <code>value</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory();

<span class="hljs-comment">// Set all tuple elements to the same value:</span>
tuple.fill( <span class="hljs-number">2.0</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-comment">// Set all tuple elements starting from the first index to the same value:</span>
tuple.fill( <span class="hljs-number">3.0</span>, <span class="hljs-number">1</span> );

x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 3.0</span>

<span class="hljs-comment">// Set all tuple elements, except the last element, to the same value:</span>
tuple.fill( <span class="hljs-number">4.0</span>, <span class="hljs-number">0</span>, tuple.length-<span class="hljs-number">1</span> );

x = tuple.x;
<span class="hljs-comment">// returns 4.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 3.0</span>
</code></pre><p>When a <code>start</code> and/or <code>end</code> index is negative, the respective index is determined relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory();

<span class="hljs-comment">// Set all tuple elements, except the last element, to the same value:</span>
tuple.fill( <span class="hljs-number">2.0</span>, -tuple.length, -<span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p><a name="method-filter"></a></p><h4 id="tuplefilter-predicate-thisarg-">tuple.filter( predicate[, thisArg] )</h4><p>Creates a new tuple (of the same data type as the host tuple) which includes those elements for which a <code>predicate</code> function returns a truthy value.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v >= <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> p2 = p1.filter( predicate );

<span class="hljs-keyword">var</span> f = p2.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>
</code></pre><p>If a <code>predicate</code> function does not return a truthy value for any tuple element, the method returns <code>null</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v >= <span class="hljs-number">10.0</span> );
}

<span class="hljs-keyword">var</span> p2 = p1.filter( predicate );
<span class="hljs-comment">// returns null</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v >= <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> p2 = p1.filter( predicate, ctx );

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-find"></a></p><h4 id="tuplefind-predicate-thisarg-">tuple.find( predicate[, thisArg] )</h4><p>Returns the first tuple element for which a provided <code>predicate</code> function returns a truthy value.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> v = tuple.find( predicate );
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>If a <code>predicate</code> function does not return a truthy value for any tuple element, the method returns <code>undefined</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; -<span class="hljs-number">10.0</span> );
}

<span class="hljs-keyword">var</span> v = tuple.find( predicate );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> v = tuple.find( predicate, ctx );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-find-field"></a></p><h4 id="tuplefindfield-predicate-thisarg-">tuple.findField( predicate[, thisArg] )</h4><p>Returns the field of the first tuple element for which a provided <code>predicate</code> function returns a truthy value.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> field = tuple.findField( predicate );
<span class="hljs-comment">// returns 'z'</span>
</code></pre><p>If a <code>predicate</code> function does not return a truthy value for any tuple element, the method returns <code>undefined</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; -<span class="hljs-number">10.0</span> );
}

<span class="hljs-keyword">var</span> field = tuple.findField( predicate );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> field = tuple.findField( predicate, ctx );
<span class="hljs-comment">// returns 'z'</span>

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-find-index"></a></p><h4 id="tuplefindindex-predicate-thisarg-">tuple.findIndex( predicate[, thisArg] )</h4><p>Returns the index of the first tuple element for which a provided <code>predicate</code> function returns a truthy value.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> idx = tuple.findIndex( predicate );
<span class="hljs-comment">// returns 2</span>
</code></pre><p>If a <code>predicate</code> function does not return a truthy value for any tuple element, the method returns <code>-1</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; -<span class="hljs-number">10.0</span> );
}

<span class="hljs-keyword">var</span> idx = tuple.findIndex( predicate );
<span class="hljs-comment">// returns -1</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> idx = tuple.findIndex( predicate, ctx );
<span class="hljs-comment">// returns 2</span>

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-for-each"></a></p><h4 id="tupleforeach-fcn-thisarg-">tuple.forEach( fcn[, thisArg] )</h4><p>Invokes a callback for each tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = <span class="hljs-string">''</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> v, i, f </span>) </span>{
    str += f + <span class="hljs-string">'='</span> + v;
    <span class="hljs-keyword">if</span> ( i &#x3C; tuple.length-<span class="hljs-number">1</span> ) {
        str += <span class="hljs-string">' '</span>;
    }
}

tuple.forEach( fcn );

<span class="hljs-built_in">console</span>.log( str );
<span class="hljs-comment">// => 'x=1 y=0 z=-1'</span>
</code></pre><p>The callback is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

tuple.forEach( fcn, ctx );

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-includes"></a></p><h4 id="tupleincludes-searchelement-fromindex-">tuple.includes( searchElement[, fromIndex] )</h4><p>Returns a <code>boolean</code> indicating whether a tuple includes a search element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> bool = tuple.includes( -<span class="hljs-number">1.0</span> );
<span class="hljs-comment">// returns true</span>

bool = tuple.includes( <span class="hljs-number">2.0</span> );
<span class="hljs-comment">// returns false</span>
</code></pre><p>By default, the method searches the entire tuple (<code>fromIndex = 0</code>). To begin searching from a specific tuple index, provide a <code>fromIndex</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> bool = tuple.includes( <span class="hljs-number">1.0</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns false</span>
</code></pre><p>When a <code>fromIndex</code> is negative, the starting index is resolved relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> bool = tuple.includes( <span class="hljs-number">1.0</span>, -<span class="hljs-number">2</span> );
<span class="hljs-comment">// returns false</span>
</code></pre><p>The method does <strong>not</strong> distinguish between signed and unsigned zero.</p><p><a name="method-index-of"></a></p><h4 id="tupleindexof-searchelement-fromindex-">tuple.indexOf( searchElement[, fromIndex] )</h4><p>Returns the index of the first tuple element strictly equal to a search element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.indexOf( -<span class="hljs-number">1.0</span> );
<span class="hljs-comment">// returns 2</span>

idx = tuple.indexOf( <span class="hljs-number">2.0</span> );
<span class="hljs-comment">// returns -1</span>
</code></pre><p>By default, the method searches the entire tuple (<code>fromIndex = 0</code>). To begin searching from a specific tuple index, provide a <code>fromIndex</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.indexOf( <span class="hljs-number">1.0</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns -1</span>
</code></pre><p>When a <code>fromIndex</code> is negative, the starting index is resolved relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.indexOf( <span class="hljs-number">1.0</span>, -<span class="hljs-number">2</span> );
<span class="hljs-comment">// returns -1</span>
</code></pre><p>The method does <strong>not</strong> distinguish between signed and unsigned zero.</p><p><a name="method-ind2key"></a></p><h4 id="tupleind2key-ind-">tuple.ind2key( ind )</h4><p>Converts a tuple index to a field name.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.ind2key( <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns 'y'</span>

field = tuple.ind2key( <span class="hljs-number">100</span> );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>If provided a negative index, the method resolves the index relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.ind2key( -<span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 'y'</span>
</code></pre><p><a name="method-join"></a></p><h4 id="tuplejoin-separator-">tuple.join( [separator] )</h4><p>Serializes a tuple by joining all tuple elements as a string.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = tuple.join();
<span class="hljs-comment">// returns '1,0,-1'</span>
</code></pre><p>By default, the method delineates tuple elements using a comma <code>,</code>. To specify a custom separator, provide a <code>separator</code> string.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = tuple.join( <span class="hljs-string">'|'</span> );
<span class="hljs-comment">// returns '1|0|-1'</span>
</code></pre><p><a name="method-keys"></a></p><h4 id="tuplekeys">tuple.keys()</h4><p>Returns an iterator for iterating over tuple keys.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Create an iterator:</span>
<span class="hljs-keyword">var</span> it = tuple.keys();

<span class="hljs-comment">// Iterate over keys...</span>
<span class="hljs-keyword">var</span> v = it.next().value;
<span class="hljs-comment">// returns [ 0, 'x' ]</span>

v = it.next().value;
<span class="hljs-comment">// returns [ 1, 'y' ]</span>

<span class="hljs-keyword">var</span> bool = it.next().done;
<span class="hljs-comment">// returns true</span>
</code></pre><p><a name="method-key2ind"></a></p><h4 id="tuplekey2ind-field-">tuple.key2ind( field )</h4><p>Converts a field name to a tuple index.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.key2ind( <span class="hljs-string">'y'</span> );
<span class="hljs-comment">// returns 1</span>

idx = tuple.key2ind( <span class="hljs-string">'foo'</span> );
<span class="hljs-comment">// returns -1</span>
</code></pre><p><a name="method-last-field-of"></a></p><h4 id="tuplelastfieldof-searchelement-fromindex-">tuple.lastFieldOf( searchElement[, fromIndex] )</h4><p>Returns the field of the last tuple element strictly equal to a search element, iterating from right to left.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.lastFieldOf( <span class="hljs-number">0.0</span> );
<span class="hljs-comment">// returns 'w'</span>

field = tuple.lastFieldOf( <span class="hljs-number">2.0</span> );
<span class="hljs-comment">// returns undefined</span>
</code></pre><p>By default, the method searches the entire tuple (<code>fromIndex = -1</code>). To begin searching from a specific tuple index, provide a <code>fromIndex</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.lastFieldOf( <span class="hljs-number">0.0</span>, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 'y'</span>
</code></pre><p>When a <code>fromIndex</code> is negative, the starting index is resolved relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> field = tuple.lastFieldOf( <span class="hljs-number">0.0</span>, -<span class="hljs-number">3</span> );
<span class="hljs-comment">// returns 'y'</span>
</code></pre><p>The method does <strong>not</strong> distinguish between signed and unsigned zero.</p><p><a name="method-last-index-of"></a></p><h4 id="tuplelastindexof-searchelement-fromindex-">tuple.lastIndexOf( searchElement[, fromIndex] )</h4><p>Returns the index of the last tuple element strictly equal to a search element, iterating from right to left.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.lastIndexOf( <span class="hljs-number">0.0</span> );
<span class="hljs-comment">// returns 3</span>

idx = tuple.lastIndexOf( <span class="hljs-number">2.0</span> );
<span class="hljs-comment">// returns -1</span>
</code></pre><p>By default, the method searches the entire tuple (<code>fromIndex = -1</code>). To begin searching from a specific tuple index, provide a <code>fromIndex</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.lastIndexOf( <span class="hljs-number">0.0</span>, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 1</span>
</code></pre><p>When a <code>fromIndex</code> is negative, the starting index is resolved relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'v'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> idx = tuple.lastIndexOf( <span class="hljs-number">0.0</span>, -<span class="hljs-number">3</span> );
<span class="hljs-comment">// returns 1</span>
</code></pre><p>The method does <strong>not</strong> distinguish between signed and unsigned zero.</p><p><a name="method-map"></a></p><h4 id="tuplemap-fcn-thisarg-">tuple.map( fcn[, thisArg] )</h4><p>Maps each tuple element to an element in a new tuple having the same data type as the host tuple.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> p2 = p1.map( fcn );

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> z = p2.z;
<span class="hljs-comment">// returns -2.0</span>
</code></pre><p>A callback is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2.0</span>;
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> p2 = p1.map( fcn, ctx );

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 3</span>
</code></pre><p><a name="method-reduce"></a></p><h4 id="tuplereduce-fcn-initialvalue-">tuple.reduce( fcn[, initialValue] )</h4><p>Applies a function against an accumulator and each element in a tuple and returns the accumulated result.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">3.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> acc, v </span>) </span>{
    <span class="hljs-keyword">return</span> acc + ( v*v );
}

<span class="hljs-keyword">var</span> v = tuple.reduce( fcn );
<span class="hljs-comment">// returns 11.0</span>
</code></pre><p>If not provided an initial value, the method invokes a provided function with the first tuple element as the first argument and the second tuple element as the second argument.</p><p>If provided an initial value, the method invokes a provided function with the initial value as the first argument and the first tuple element as the second argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">3.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> acc, v </span>) </span>{
    <span class="hljs-keyword">return</span> acc + ( v*v );
}

<span class="hljs-keyword">var</span> v = tuple.reduce( fcn, <span class="hljs-number">0.0</span> );
<span class="hljs-comment">// returns 13.0</span>
</code></pre><p>A callback is provided five arguments:</p><ul><li><code>acc</code>: accumulated result.</li><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p><a name="method-reduce-right"></a></p><h4 id="tuplereduceright-fcn-initialvalue-">tuple.reduceRight( fcn[, initialValue] )</h4><p>Applies a function against an accumulator and each element in a tuple and returns the accumulated result, iterating from right to left.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">3.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> acc, v </span>) </span>{
    <span class="hljs-keyword">return</span> acc + ( v*v );
}

<span class="hljs-keyword">var</span> v = tuple.reduceRight( fcn );
<span class="hljs-comment">// returns 1.0</span>
</code></pre><p>If not provided an initial value, the method invokes a provided function with the last tuple element as the first argument and the second-to-last tuple element as the second argument.</p><p>If provided an initial value, the method invokes a provided function with the initial value as the first argument and the last tuple element as the second argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">3.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fcn</span>(<span class="hljs-params"> acc, v </span>) </span>{
    <span class="hljs-keyword">return</span> acc + ( v*v );
}

<span class="hljs-keyword">var</span> v = tuple.reduceRight( fcn, <span class="hljs-number">0.0</span> );
<span class="hljs-comment">// returns 13.0</span>
</code></pre><p>A callback is provided five arguments:</p><ul><li><code>acc</code>: accumulated result.</li><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p><a name="method-reverse"></a></p><h4 id="tuplereverse">tuple.reverse()</h4><p>Reverses a tuple <strong>in-place</strong> (thus mutating the tuple on which the method is invoked).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">3.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 2.0</span>

x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-comment">// Reverse the tuple:</span>
tuple.reverse();

<span class="hljs-keyword">var</span> fields = tuple.orderedFields;
<span class="hljs-comment">// returns [ 'z', 'y', 'x' ]</span>

<span class="hljs-keyword">var</span> z = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns -3.0</span>

<span class="hljs-comment">// Tuple field assignments do NOT change:</span>
x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>
</code></pre><p>Invoking this method does <strong>not</strong> affect tuple field assignments.</p><p><a name="method-set"></a></p><h4 id="tupleset-arr-offset-">tuple.set( arr[, offset] )</h4><p>Sets tuple elements.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Set the first two tuple elements:</span>
tuple.set( [ -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns -2.0</span>

x = tuple.x;
<span class="hljs-comment">// returns -2.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 2.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 2.0</span>
</code></pre><p>By default, the method starts writing values at the first tuple index. To specify an alternative index, provide an index <code>offset</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>

y = tuple.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Set the last two tuple elements:</span>
tuple.set( [ -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> ], <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

x = tuple.x;
<span class="hljs-comment">// returns 1.0</span>

y = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -2.0</span>

y = tuple.y;
<span class="hljs-comment">// returns -2.0</span>

<span class="hljs-keyword">var</span> z = tuple[ <span class="hljs-number">2</span> ];
<span class="hljs-comment">// returns 2.0</span>

z = tuple.z;
<span class="hljs-comment">// returns 2.0</span>
</code></pre><p><a name="method-slice"></a></p><h4 id="tupleslice-begin-end-">tuple.slice( [begin[, end]] )</h4><p>Copies tuple elements to a new tuple with the same underlying data type as the host tuple.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.slice();

<span class="hljs-keyword">var</span> bool = ( p1 === p2 );
<span class="hljs-comment">// returns false</span>

bool = ( p1.buffer === p2.buffer );
<span class="hljs-comment">// returns false</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> z = p2.z;
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>By default, the method copies elements beginning with the first tuple element. To specify an alternative tuple index at which to begin copying, provide a <code>begin</code> index (inclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.slice( <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'y', 'z' ]</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> z = p2.z;
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>By default, the method copies all tuple elements after <code>begin</code>. To specify an alternative tuple index at which to end copying, provide an <code>end</code> index (exclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.slice( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p>When a <code>begin</code> and/or <code>end</code> index is negative, the respective index is determined relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.slice( -p1.length, -<span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p><a name="method-some"></a></p><h4 id="tuplesome-predicate-thisarg-">tuple.some( predicate[, thisArg] )</h4><p>Tests whether at least one tuple element passes a test implemented by a <code>predicate</code> function.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> bool = tuple.some( predicate );
<span class="hljs-comment">// returns true</span>
</code></pre><p>A <code>predicate</code> function is provided four arguments:</p><ul><li><code>value</code>: tuple element.</li><li><code>index</code>: tuple index.</li><li><code>field</code>: tuple field name.</li><li><code>tuple</code>: tuple on which the method is invoked.</li></ul><p>To set the callback execution context, provide a <code>thisArg</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">predicate</span>(<span class="hljs-params"> v </span>) </span>{
    <span class="hljs-built_in">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> ( v &#x3C; <span class="hljs-number">0.0</span> );
}

<span class="hljs-keyword">var</span> ctx = {
    <span class="hljs-string">'count'</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">var</span> bool = tuple.some( predicate, ctx );
<span class="hljs-comment">// returns false</span>

<span class="hljs-keyword">var</span> n = ctx.count;
<span class="hljs-comment">// returns 2</span>
</code></pre><p><a name="method-sort"></a></p><h4 id="tuplesort-comparefunction-">tuple.sort( [compareFunction] )</h4><p>Sorts a tuple <strong>in-place</strong> (thus mutating the tuple on which the method is invoked).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, -<span class="hljs-number">3.0</span>, <span class="hljs-number">0.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 2.0</span>

x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-comment">// Sort the tuple (in ascending order):</span>
tuple.sort();

<span class="hljs-keyword">var</span> fields = tuple.orderedFields;
<span class="hljs-comment">// returns [ 'y', 'z', 'x' ]</span>

<span class="hljs-keyword">var</span> y = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns -3.0</span>

<span class="hljs-comment">// Tuple field assignments do NOT change:</span>
x = tuple.x;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p>By default, the method sorts tuple elements in ascending order. To impose a custom order, provide a <code>compareFunction</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">2.0</span>, -<span class="hljs-number">3.0</span>, <span class="hljs-number">0.0</span> ] );

<span class="hljs-keyword">var</span> x = tuple[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 2.0</span>

x = tuple.x;
<span class="hljs-comment">// returns 2.0</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">descending</span>(<span class="hljs-params"> a, b </span>) </span>{
    <span class="hljs-keyword">return</span> b - a;
}

<span class="hljs-comment">// Sort the tuple (in descending order):</span>
tuple.sort( descending );

<span class="hljs-keyword">var</span> fields = tuple.orderedFields;
<span class="hljs-comment">// returns [ 'x', 'z', 'y' ]</span>

<span class="hljs-keyword">var</span> z = tuple[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Tuple field assignments do NOT change:</span>
<span class="hljs-keyword">var</span> y = tuple.y;
<span class="hljs-comment">// returns -3.0</span>
</code></pre><p>The comparison function is provided two tuple elements, <code>a</code> and <code>b</code>, per invocation, and its return value determines the sort order as follows:</p><ul><li>If the comparison function returns a value <strong>less</strong> than zero, then the method sorts <code>a</code> to an index lower than <code>b</code> (i.e., <code>a</code> should come <strong>before</strong> <code>b</code>).</li><li>If the comparison function returns a value <strong>greater</strong> than zero, then the method sorts <code>a</code> to an index higher than <code>b</code> (i.e., <code>b</code> should come <strong>before</strong> <code>a</code>).</li><li>If the comparison function returns <strong>zero</strong>, then the relative order of <code>a</code> and <code>b</code> <em>should</em> remain unchanged.</li></ul><p>Invoking this method does <strong>not</strong> affect tuple field assignments.</p><p><a name="method-subarray"></a></p><h4 id="tuplesubarray-begin-end-">tuple.subarray( [begin[, end]] )</h4><p>Creates a new <a href="/docs/api/latest/@stdlib/array/typed">typed array</a> over the same underlying <a href="/docs/api/latest/@stdlib/array/buffer"><code>ArrayBuffer</code></a> and with the same underlying data type as the host tuple.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> arr = tuple.subarray();
<span class="hljs-comment">// returns &#x3C;Float64Array>[ 1.0, 0.0, -1.0 ]</span>
</code></pre><p>By default, the method creates a <a href="/docs/api/latest/@stdlib/array/typed">typed array</a> view beginning with the first tuple element. To specify an alternative tuple index at which to begin, provide a <code>begin</code> index (inclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> arr = tuple.subarray( <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns &#x3C;Float64Array>[ 0.0, -1.0 ]</span>
</code></pre><p>By default, the method creates a <a href="/docs/api/latest/@stdlib/array/typed">typed array</a> view which includes all tuple elements after <code>begin</code>. To limit the number of tuple elements after <code>begin</code>, provide an <code>end</code> index (exclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> arr = tuple.subarray( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns &#x3C;Float64Array>[ 1.0, 0.0 ]</span>
</code></pre><p>When a <code>begin</code> and/or <code>end</code> index is negative, the respective index is determined relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> arr = tuple.subarray( -tuple.length, -<span class="hljs-number">1</span> );
<span class="hljs-comment">// returns &#x3C;Float64Array>[ 1.0, 0.0 ]</span>
</code></pre><p>If the method is unable to resolve indices to a non-empty tuple subsequence, the method returns an empty <a href="/docs/api/latest/@stdlib/array/typed">typed array</a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> arr = tuple.subarray( <span class="hljs-number">10</span>, -<span class="hljs-number">1</span> );
<span class="hljs-comment">// returns &#x3C;Float64Array>[]</span>
</code></pre><p><a name="method-subtuple"></a></p><h4 id="tuplesubtuple-begin-end-">tuple.subtuple( [begin[, end]] )</h4><p>Creates a new named typed tuple over the same underlying <a href="/docs/api/latest/@stdlib/array/buffer"><code>ArrayBuffer</code></a> and with the same underlying data type as the host tuple.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.subtuple();

<span class="hljs-keyword">var</span> bool = ( p1 === p2 );
<span class="hljs-comment">// returns false</span>

bool = ( p1.buffer === p2.buffer );
<span class="hljs-comment">// returns true</span>

<span class="hljs-keyword">var</span> len = p2.length;
<span class="hljs-comment">// returns 3</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> z = p2.z;
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>By default, the method creates a new tuple beginning with the first tuple element. To specify an alternative tuple index at which to begin, provide a <code>begin</code> index (inclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.subtuple( <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> len = p2.length;
<span class="hljs-comment">// returns 2</span>

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'y', 'z' ]</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-keyword">var</span> z = p2.z;
<span class="hljs-comment">// returns -1.0</span>
</code></pre><p>By default, the method creates a new tuple which includes all tuple elements after <code>begin</code>. To limit the number of tuple elements after <code>begin</code>, provide an <code>end</code> index (exclusive).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.subtuple( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> len = p2.length;
<span class="hljs-comment">// returns 2</span>

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p>When a <code>begin</code> and/or <code>end</code> index is negative, the respective index is determined relative to the last tuple element.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.subtuple( -p1.length, -<span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> len = p2.length;
<span class="hljs-comment">// returns 2</span>

<span class="hljs-keyword">var</span> fields = p2.fields;
<span class="hljs-comment">// returns [ 'x', 'y' ]</span>

<span class="hljs-keyword">var</span> x = p2.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p2.y;
<span class="hljs-comment">// returns 0.0</span>
</code></pre><p>If the method is unable to resolve indices to a non-empty tuple subsequence, the method returns <code>null</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> p1 = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> p2 = p1.subtuple( <span class="hljs-number">10</span>, -<span class="hljs-number">1</span> );
<span class="hljs-comment">// returns null</span>
</code></pre><p><a name="method-to-json"></a></p><h4 id="tupletojson">tuple.toJSON()</h4><p>Serializes a tuple as <a href="http://www.json.org/">JSON</a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-keyword">var</span> obj = tuple.toJSON();
<span class="hljs-comment">// returns { 'x': 1.0, 'y': 0.0, 'z': -1.0 }</span>
</code></pre><p><a name="method-to-locale-string"></a></p><h4 id="tupletolocalestring-locales-options-">tuple.toLocaleString( [locales[, options]] )</h4><p>Serializes a tuple as a locale-specific <code>string</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = tuple.toLocaleString();
<span class="hljs-comment">// returns '1,0,-1'</span>
</code></pre><p><a name="method-to-string"></a></p><h4 id="tupletostring">tuple.toString()</h4><p>Serializes a tuple as a <code>string</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = tuple.toString();
<span class="hljs-comment">// returns 'tuple(x=1, y=0, z=-1)'</span>
</code></pre><p>The returned <code>string</code> uses the tuple <code>name</code> as specified when creating a tuple factory.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Point'</span>
};

<span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> ], opts );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">1.0</span> ], <span class="hljs-string">'int32'</span> );

<span class="hljs-keyword">var</span> str = tuple.toString();
<span class="hljs-comment">// returns 'Point(x=1, y=0, z=-1)'</span>
</code></pre><p><a name="method-values"></a></p><h4 id="tuplevalues">tuple.values()</h4><p>Returns an iterator for iterating over tuple elements.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Create an iterator:</span>
<span class="hljs-keyword">var</span> it = tuple.values();

<span class="hljs-comment">// Iterate over tuple elements...</span>
<span class="hljs-keyword">var</span> v = it.next().value;
<span class="hljs-comment">// returns 1.0</span>

v = it.next().value;
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> bool = it.next().done;
<span class="hljs-comment">// returns true</span>
</code></pre></section><section class="notes"><hr><h2 id="notes">Notes</h2><ul><li><p>Named typed tuples are <strong>not</strong> immutable. In order to create immutable named typed tuples, invoke <code>Object.freeze()</code> on returned tuples.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> factory = namedtypedtuple( [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ] );

<span class="hljs-keyword">var</span> tuple = factory( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Make the tuple immutable:</span>
tuple = <span class="hljs-built_in">Object</span>.freeze( tuple );
</code></pre></li><li><p>Tuple fields are <strong>non-enumerable</strong>. To return the list of tuple fields, use <a href="#prop-fields"><code>tuple.fields</code></a>.</p></li></ul></section><section class="examples"><hr><h2 id="examples">Examples</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> namedtypedtuple = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/utils/named-typed-tuple'</span> );

<span class="hljs-keyword">var</span> fields = [ <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span> ];
<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Point'</span>
};

<span class="hljs-keyword">var</span> Point = namedtypedtuple( fields, opts );

<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Point( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Tuple elements can be accessed by index or name:</span>
<span class="hljs-keyword">var</span> x = p[ <span class="hljs-number">0</span> ];
<span class="hljs-comment">// returns 1.0</span>

x = p.x;
<span class="hljs-comment">// returns 1.0</span>

<span class="hljs-keyword">var</span> y = p[ <span class="hljs-number">1</span> ];
<span class="hljs-comment">// returns -1.0</span>

y = p.y;
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-comment">// Sort tuple elements while retaining name access:</span>
p.sort();
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">'p[0]=%d, p[1]=%d, x=%d, y=%d'</span>, p[ <span class="hljs-number">0</span> ], p[ <span class="hljs-number">1</span> ], p.x, p.y );

<span class="hljs-comment">// Retrieve the tuple fields in index order:</span>
<span class="hljs-built_in">console</span>.log( p.orderedFields );
<span class="hljs-comment">// => [ 'y', 'x' ]</span>

<span class="hljs-comment">// Serialize the tuple as a string:</span>
<span class="hljs-built_in">console</span>.log( p.toString() );

<span class="hljs-comment">// Serialize the tuple a JSON string:</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">JSON</span>.stringify( p ) );
</code></pre></section><section class="references"></section><section class="related"><hr><h2 id="see-also">See Also</h2><ul><li><span class="package-name"><a href="/docs/api/latest/@stdlib/array/typed"><code>@stdlib/array/typed</code></a></span><span class="delimiter">: </span><span class="description">create a typed array.</span></li></ul></section><section class="links"></section>