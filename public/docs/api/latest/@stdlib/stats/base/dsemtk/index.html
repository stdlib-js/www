<h1 id="dsemtk">dsemtk</h1><blockquote><p>Calculate the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> of a double-precision floating-point strided array using a one-pass textbook algorithm.</p></blockquote><section class="intro"><p>The <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> of a finite size sample of size <code>n</code> is given by</p><div class="equation" align="center" data-raw-text="\sigma_{\bar{x}} = \frac{\sigma}{\sqrt{n}}" data-equation="eq:standard_error_of_the_mean"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.77ex" height="5.676ex" style="vertical-align:-2.838ex" viewBox="0 -1221.9 4206.7 2443.8" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">sigma Subscript x overbar Baseline equals StartFraction sigma Over StartRoot n EndRoot EndFraction</title><defs aria-hidden="true"></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"><g transform="translate(571,-150)"></g><g transform="translate(2134,0)"><g transform="translate(397,0)"><g transform="translate(60,-803)"></g></g></g></g></svg></div><p>where <code>σ</code> is the population <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>.</p><p>Often in the analysis of data, the true population <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> is not known <em>a priori</em> and must be estimated from a sample drawn from the population distribution. In this scenario, one must use a sample <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> to compute an estimate for the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a></p><div class="equation" align="center" data-raw-text="\sigma_{\bar{x}} \approx \frac{s}{\sqrt{n}}" data-equation="eq:standard_error_of_the_mean_estimate"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.77ex" height="5.676ex" style="vertical-align:-2.838ex" viewBox="0 -1221.9 4206.7 2443.8" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">sigma Subscript x overbar Baseline almost-equals StartFraction s Over StartRoot n EndRoot EndFraction</title><defs aria-hidden="true"></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"><g transform="translate(571,-150)"></g><g transform="translate(2134,0)"><g transform="translate(397,0)"><g transform="translate(60,-803)"></g></g></g></g></svg></div><p>where <code>s</code> is the sample <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>.</p></section><section class="usage"><h2 id="usage">Usage</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> dsemtk = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/stats/base/dsemtk'</span> );
</code></pre><h4 id="dsemtk-n-correction-x-stride-">dsemtk( N, correction, x, stride )</h4><p>Computes the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> of a double-precision floating-point strided array <code>x</code> using a one-pass textbook algorithm.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> ] );
<span class="hljs-keyword">var</span> N = x.length;

<span class="hljs-keyword">var</span> v = dsemtk( N, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns ~1.20185</span>
</code></pre><p>The function has the following parameters:</p><ul><li><strong>N</strong>: number of indexed elements.</li><li><strong>correction</strong>: degrees of freedom adjustment. Setting this parameter to a value other than <code>0</code> has the effect of adjusting the divisor during the calculation of the <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> according to <code>N-c</code> where <code>c</code> corresponds to the provided degrees of freedom adjustment. When computing the <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of a population, setting this parameter to <code>0</code> is the standard choice (i.e., the provided array contains data constituting an entire population). When computing the corrected sample <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>, setting this parameter to <code>1</code> is the standard choice (i.e., the provided array contains data sampled from a larger population; this is commonly referred to as Bessel's correction).</li><li><strong>x</strong>: input <a href="/docs/api/latest/@stdlib/array/float64"><code>Float64Array</code></a>.</li><li><strong>stride</strong>: index increment for <code>x</code>.</li></ul><p>The <code>N</code> and <code>stride</code> parameters determine which elements in <code>x</code> are accessed at runtime. For example, to compute the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> of every other element in <code>x</code>,</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );
<span class="hljs-keyword">var</span> floor = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/special/floor'</span> );

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, -<span class="hljs-number">7.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">2.0</span> ] );
<span class="hljs-keyword">var</span> N = floor( x.length / <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> v = dsemtk( N, <span class="hljs-number">1</span>, x, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 1.25</span>
</code></pre><p>Note that indexing is relative to the first index. To introduce an offset, use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>typed array</code></a> views.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );
<span class="hljs-keyword">var</span> floor = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/special/floor'</span> );

<span class="hljs-keyword">var</span> x0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ] );
<span class="hljs-keyword">var</span> x1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( x0.buffer, x0.BYTES_PER_ELEMENT*<span class="hljs-number">1</span> ); <span class="hljs-comment">// start at 2nd element</span>

<span class="hljs-keyword">var</span> N = floor( x0.length / <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> v = dsemtk( N, <span class="hljs-number">1</span>, x1, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 1.25</span>
</code></pre><h4 id="dsemtkndarray-n-correction-x-stride-offset-">dsemtk.ndarray( N, correction, x, stride, offset )</h4><p>Computes the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> of a double-precision floating-point strided array using a one-pass textbook algorithm and alternative indexing semantics.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> ] );
<span class="hljs-keyword">var</span> N = x.length;

<span class="hljs-keyword">var</span> v = dsemtk.ndarray( N, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );
<span class="hljs-comment">// returns ~1.20185</span>
</code></pre><p>The function has the following additional parameters:</p><ul><li><strong>offset</strong>: starting index for <code>x</code>.</li></ul><p>While <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>typed array</code></a> views mandate a view offset based on the underlying <code>buffer</code>, the <code>offset</code> parameter supports indexing semantics based on a starting index. For example, to calculate the <a href="https://en.wikipedia.org/wiki/Standard_error">standard error of the mean</a> for every other value in <code>x</code> starting from the second value</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );
<span class="hljs-keyword">var</span> floor = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/special/floor'</span> );

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ] );
<span class="hljs-keyword">var</span> N = floor( x.length / <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> v = dsemtk.ndarray( N, <span class="hljs-number">1</span>, x, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns 1.25</span>
</code></pre></section><section class="notes"><h2 id="notes">Notes</h2><ul><li>If <code>N &#x3C;= 0</code>, both functions return <code>NaN</code>.</li><li>If <code>N - c</code> is less than or equal to <code>0</code> (where <code>c</code> corresponds to the provided degrees of freedom adjustment), both functions return <code>NaN</code>.</li><li>Some caution should be exercised when using the one-pass textbook algorithm. Literature overwhelmingly discourages the algorithm's use for two reasons: 1) the lack of safeguards against underflow and overflow and 2) the risk of catastrophic cancellation. These concerns have merit; however, the one-pass textbook algorithm should not be dismissed outright. For data distributions with a moderately large standard deviation to mean ratio (i.e., <strong>coefficient of variation</strong>), the one-pass textbook algorithm may be acceptable, especially when performance is paramount and some precision loss is acceptable (including a risk of computing a negative variance due to floating-point rounding errors!). In short, no single "best" algorithm for computing the standard error of the mean exists. The "best" algorithm depends on the underlying data distribution, your performance requirements, and your minimum precision requirements. When evaluating which algorithm to use, consider the relative pros and cons, and choose the algorithm which best serves your needs.</li></ul></section><section class="examples"><h2 id="examples">Examples</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> randu = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/random/base/randu'</span> );
<span class="hljs-keyword">var</span> round = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/special/round'</span> );
<span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );
<span class="hljs-keyword">var</span> dsemtk = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/stats/base/dsemtk'</span> );

<span class="hljs-keyword">var</span> x;
<span class="hljs-keyword">var</span> i;

x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( <span class="hljs-number">10</span> );
<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; x.length; i++ ) {
    x[ i ] = round( (randu()*<span class="hljs-number">100.0</span>) - <span class="hljs-number">50.0</span> );
}
<span class="hljs-built_in">console</span>.log( x );

<span class="hljs-keyword">var</span> v = dsemtk( x.length, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span> );
<span class="hljs-built_in">console</span>.log( v );
</code></pre></section><hr><section class="references"><h2 id="references">References</h2><ul><li>Ling, Robert F. 1974. "Comparison of Several Algorithms for Computing Sample Means and Variances." <em>Journal of the American Statistical Association</em> 69 (348). American Statistical Association, Taylor &#x26; Francis, Ltd.: 859–66. doi:<a href="https://doi.org/10.2307/2286154">10.2307/2286154</a>.</li></ul></section><section class="related"><hr><h2 id="see-also">See Also</h2><ul><li><span class="package-name"><a href="/docs/api/latest/@stdlib/stats/base/dsem"><code>@stdlib/stats/base/dsem</code></a></span><span class="delimiter">: </span><span class="description">calculate the standard error of the mean for a double-precision floating-point strided array.</span></li><li><span class="package-name"><a href="/docs/api/latest/@stdlib/stats/base/dstdevtk"><code>@stdlib/stats/base/dstdevtk</code></a></span><span class="delimiter">: </span><span class="description">calculate the standard deviation of a double-precision floating-point strided array using a one-pass textbook algorithm.</span></li></ul></section>