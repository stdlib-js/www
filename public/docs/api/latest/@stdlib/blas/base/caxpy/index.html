<h1 id="caxpy">caxpy</h1><blockquote><p>Scale a single-precision complex floating-point vector by a single-precision complex floating-point constant and add the result to a single-precision complex floating-point vector.</p></blockquote><section class="usage"><h2 id="usage">Usage</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> caxpy = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/blas/base/caxpy'</span> );
</code></pre><h4 id="caxpy-n-ca-cx-stridex-cy-stridey-">caxpy( N, ca, cx, strideX, cy, strideY )</h4><p>Scales values from <code>cx</code> by <code>ca</code> and adds the result to <code>cy</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Complex64Array = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/complex64'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> realf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/real'</span> );
<span class="hljs-keyword">var</span> imagf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/imag'</span> );

<span class="hljs-keyword">var</span> cx = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span> ] );
<span class="hljs-keyword">var</span> cy = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );
<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

caxpy( <span class="hljs-number">3</span>, ca, cx, <span class="hljs-number">1</span>, cy, <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> z = cy.get( <span class="hljs-number">0</span> );
<span class="hljs-comment">// returns &#x3C;Complex64></span>

<span class="hljs-keyword">var</span> re = realf( z );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> im = imagf( z );
<span class="hljs-comment">// returns 7.0</span>
</code></pre><p>The function has the following parameters:</p><ul><li><strong>N</strong>: number of indexed elements.</li><li><strong>ca</strong>: scalar <a href="/docs/api/latest/@stdlib/complex/float32/ctor"><code>Complex64</code></a> constant.</li><li><strong>cx</strong>: first input <a href="/docs/api/latest/@stdlib/array/complex64"><code>Complex64Array</code></a>.</li><li><strong>strideX</strong>: index increment for <code>cx</code>.</li><li><strong>cy</strong>: second input <a href="/docs/api/latest/@stdlib/array/complex64"><code>Complex64Array</code></a>.</li><li><strong>strideY</strong>: index increment for <code>cy</code>.</li></ul><p>The <code>N</code> and stride parameters determine how values from <code>cx</code> are scaled by <code>ca</code> and added to <code>cy</code>. For example, to scale every other value in <code>cx</code> by <code>ca</code> and add the result to every other value of <code>cy</code>,</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Complex64Array = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/complex64'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> realf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/real'</span> );
<span class="hljs-keyword">var</span> imagf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/imag'</span> );

<span class="hljs-keyword">var</span> cx = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ] );
<span class="hljs-keyword">var</span> cy = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );
<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

caxpy( <span class="hljs-number">2</span>, ca, cx, <span class="hljs-number">2</span>, cy, <span class="hljs-number">2</span> );

<span class="hljs-keyword">var</span> z = cy.get( <span class="hljs-number">0</span> );
<span class="hljs-comment">// returns &#x3C;Complex64></span>

<span class="hljs-keyword">var</span> re = realf( z );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> im = imagf( z );
<span class="hljs-comment">// returns 7.0</span>
</code></pre><p>Note that indexing is relative to the first index. To introduce an offset, use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>typed array</code></a> views.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Complex64Array = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/complex64'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> realf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/real'</span> );
<span class="hljs-keyword">var</span> imagf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/imag'</span> );

<span class="hljs-comment">// Initial arrays...</span>
<span class="hljs-keyword">var</span> cx0 = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ] );
<span class="hljs-keyword">var</span> cy0 = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );

<span class="hljs-comment">// Define a scalar constant:</span>
<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

<span class="hljs-comment">// Create offset views...</span>
<span class="hljs-keyword">var</span> cx1 = <span class="hljs-keyword">new</span> Complex64Array( cx0.buffer, cx0.BYTES_PER_ELEMENT*<span class="hljs-number">1</span> ); <span class="hljs-comment">// start at 2nd element</span>
<span class="hljs-keyword">var</span> cy1 = <span class="hljs-keyword">new</span> Complex64Array( cy0.buffer, cy0.BYTES_PER_ELEMENT*<span class="hljs-number">2</span> ); <span class="hljs-comment">// start at 3rd element</span>

<span class="hljs-comment">// Scales values of `cx0` by `ca` starting from second index and add the result to `cy0` starting from third index...</span>
caxpy( <span class="hljs-number">2</span>, ca, cx1, <span class="hljs-number">1</span>, cy1, <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> z = cy0.get( <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns &#x3C;Complex64></span>

<span class="hljs-keyword">var</span> re = realf( z );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> im = imagf( z );
<span class="hljs-comment">// returns 15.0</span>
</code></pre><h4 id="caxpyndarray-n-ca-cx-stridex-offsetx-cy-stridey-offsety-">caxpy.ndarray( N, ca, cx, strideX, offsetX, cy, strideY, offsetY )</h4><p>Scales values from <code>cx</code> by <code>ca</code> and adds the result to <code>cy</code> using alternative indexing semantics.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Complex64Array = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/complex64'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> realf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/real'</span> );
<span class="hljs-keyword">var</span> imagf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/imag'</span> );

<span class="hljs-keyword">var</span> cx = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span> ] );
<span class="hljs-keyword">var</span> cy = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );
<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

caxpy.ndarray( <span class="hljs-number">3</span>, ca, cx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cy, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );

<span class="hljs-keyword">var</span> z = cy.get( <span class="hljs-number">0</span> );
<span class="hljs-comment">// returns &#x3C;Complex64></span>

<span class="hljs-keyword">var</span> re = realf( z );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> im = imagf( z );
<span class="hljs-comment">// returns 7.0</span>
</code></pre><p>The function has the following additional parameters:</p><ul><li><strong>offsetX</strong>: starting index for <code>cx</code>.</li><li><strong>offsetY</strong>: starting index for <code>cy</code>.</li></ul><p>While <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>typed array</code></a> views mandate a view offset based on the underlying buffer, the offset parameters support indexing semantics based on starting indices. For example, to scale values in the first input strided array starting from the second element and add the result to the second input array starting from the second element,</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Complex64Array = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/complex64'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> realf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/real'</span> );
<span class="hljs-keyword">var</span> imagf = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/imag'</span> );

<span class="hljs-keyword">var</span> cx = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ] );
<span class="hljs-keyword">var</span> cy = <span class="hljs-keyword">new</span> Complex64Array( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ] );
<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

caxpy.ndarray( <span class="hljs-number">3</span>, ca, cx, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, cy, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> z = cy.get( <span class="hljs-number">3</span> );
<span class="hljs-comment">// returns &#x3C;Complex64></span>

<span class="hljs-keyword">var</span> re = realf( z );
<span class="hljs-comment">// returns -1.0</span>

<span class="hljs-keyword">var</span> im = imagf( z );
<span class="hljs-comment">// returns 31.0</span>
</code></pre></section><section class="notes"><h2 id="notes">Notes</h2><ul><li>If <code>N &#x3C;= 0</code>, both functions return <code>cy</code> unchanged.</li><li><code>caxpy()</code> corresponds to the <a href="http://www.netlib.org/blas">BLAS</a> level 1 function <a href="https://www.netlib.org/lapack/explore-html/d5/d4b/group__axpy_ga0b7bac1f4d42514074a48f14f5f9caa0.html#ga0b7bac1f4d42514074a48f14f5f9caa0"><code>caxpy</code></a>.</li></ul></section><section class="examples"><h2 id="examples">Examples</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> discreteUniform = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/random/base/discrete-uniform'</span> );
<span class="hljs-keyword">var</span> filledarrayBy = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/filled-by'</span> );
<span class="hljs-keyword">var</span> Complex64 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/complex/float32/ctor'</span> );
<span class="hljs-keyword">var</span> ccopy = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/blas/base/ccopy'</span> );
<span class="hljs-keyword">var</span> zeros = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/zeros'</span> );
<span class="hljs-keyword">var</span> logEach = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/console/log-each'</span> );
<span class="hljs-keyword">var</span> caxpy = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/blas/base/caxpy'</span> );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rand</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Complex64( discreteUniform( <span class="hljs-number">0</span>, <span class="hljs-number">10</span> ), discreteUniform( -<span class="hljs-number">5</span>, <span class="hljs-number">5</span> ) );
}

<span class="hljs-keyword">var</span> cx = filledarrayBy( <span class="hljs-number">10</span>, <span class="hljs-string">'complex64'</span>, rand );
<span class="hljs-keyword">var</span> cy = filledarrayBy( <span class="hljs-number">10</span>, <span class="hljs-string">'complex64'</span>, rand );
<span class="hljs-keyword">var</span> cyc = ccopy( cy.length, cy, <span class="hljs-number">1</span>, zeros( cy.length, <span class="hljs-string">'complex64'</span> ), <span class="hljs-number">1</span> );

<span class="hljs-keyword">var</span> ca = <span class="hljs-keyword">new</span> Complex64( <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span> );

<span class="hljs-comment">// Scale values from `cx` by `ca` and add the result to `cy`:</span>
caxpy( cx.length, ca, cx, <span class="hljs-number">1</span>, cy, <span class="hljs-number">1</span> );

<span class="hljs-comment">// Print the results:</span>
logEach( <span class="hljs-string">'(%s)*(%s) + (%s) = %s'</span>, ca, cx, cyc, cy );
</code></pre></section><hr><section class="c"><h2 id="c-apis">C APIs</h2><section class="intro"></section><section class="usage"><h3 id="usage-1">Usage</h3><pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/blas/base/caxpy.h"</span></span>
</code></pre><h4 id="c_caxpy-n-ca-cx-stridex-cy-stridey-">c_caxpy( N, ca, *CX, strideX, *CY, strideY )</h4><p>Scales values from <code>cx</code> by <code>ca</code> and adds the result to <code>cy</code>.</p><pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/complex/float32/ctor.h"</span></span>

<span class="hljs-keyword">float</span> cx[] = { <span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">5.0f</span>, <span class="hljs-number">6.0f</span>, <span class="hljs-number">7.0f</span>, <span class="hljs-number">8.0f</span> };
<span class="hljs-keyword">float</span> cy[] = { <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-2.0f</span>, <span class="hljs-number">-3.0f</span>, <span class="hljs-number">-4.0f</span>, <span class="hljs-number">-5.0f</span>, <span class="hljs-number">-6.0f</span>, <span class="hljs-number">-7.0f</span>, <span class="hljs-number">-8.0f</span> };
<span class="hljs-keyword">const</span> <span class="hljs-keyword">stdlib_complex64_t</span> ca = stdlib_complex64( <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span> );

c_caxpy( <span class="hljs-number">4</span>, ca, (<span class="hljs-keyword">void</span> *)cx, <span class="hljs-number">1</span>, (<span class="hljs-keyword">void</span> *)cy, <span class="hljs-number">1</span> );
</code></pre><p>The function accepts the following arguments:</p><ul><li><strong>N</strong>: <code>[in] CBLAS_INT</code> number of indexed elements.</li><li><strong>ca</strong>: <code>[in] stdlib_complex64_t</code> scalar constant.</li><li><strong>CX</strong>: <code>[in] void*</code> input array.</li><li><strong>strideX</strong>: <code>[in] CBLAS_INT</code> index increment for <code>CX</code>.</li><li><strong>CY</strong>: <code>[inout] void*</code> output array.</li><li><strong>strideY</strong>: <code>[in] CBLAS_INT</code> index increment for <code>CY</code>.</li></ul><pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c_caxpy</span><span class="hljs-params">( <span class="hljs-keyword">const</span> CBLAS_INT N, <span class="hljs-keyword">const</span> <span class="hljs-keyword">stdlib_complex64_t</span> ca, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *CX, <span class="hljs-keyword">const</span> CBLAS_INT strideX, <span class="hljs-keyword">void</span> *CY, <span class="hljs-keyword">const</span> CBLAS_INT strideY )</span></span>;
</code></pre><h4 id="c_caxpy_ndarray-n-ca-cx-stridex-offsetx-cy-stridey-offsety-">c_caxpy_ndarray( N, ca, *CX, strideX, offsetX, *CY, strideY, offsetY )</h4><p>Scales values from <code>cx</code> by <code>ca</code> and adds the result to <code>cy</code> using alternative indexing semantics.</p><pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/complex/float32/ctor.h"</span></span>

<span class="hljs-keyword">float</span> cx[] = { <span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">5.0f</span>, <span class="hljs-number">6.0f</span>, <span class="hljs-number">7.0f</span>, <span class="hljs-number">8.0f</span> };
<span class="hljs-keyword">float</span> cy[] = { <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-2.0f</span>, <span class="hljs-number">-3.0f</span>, <span class="hljs-number">-4.0f</span>, <span class="hljs-number">-5.0f</span>, <span class="hljs-number">-6.0f</span>, <span class="hljs-number">-7.0f</span>, <span class="hljs-number">-8.0f</span> }
<span class="hljs-keyword">const</span> <span class="hljs-keyword">stdlib_complex64_t</span> ca = stdlib_complex64( <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span> );

c_caxpy_ndarray( <span class="hljs-number">4</span>, ca, (<span class="hljs-keyword">void</span> *)cx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span> *)cy, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );
</code></pre><p>The function accepts the following arguments:</p><ul><li><strong>N</strong>: <code>[in] CBLAS_INT</code> number of indexed elements.</li><li><strong>ca</strong>: <code>[in] stdlib_complex64_t</code> scalar constant.</li><li><strong>CX</strong>: <code>[in] void*</code> input array.</li><li><strong>strideX</strong>: <code>[in] CBLAS_INT</code> index increment for <code>CX</code>.</li><li><strong>offsetX</strong>: <code>[in] CBLAS_INT</code> starting index for <code>CX</code>.</li><li><strong>CY</strong>: <code>[inout] void*</code> output array.</li><li><strong>strideY</strong>: <code>[in] CBLAS_INT</code> index increment for <code>CY</code>.</li><li><strong>offsetY</strong>: <code>[in] CBLAS_INT</code> starting index for <code>CY</code>.</li></ul><pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c_caxpy_ndarray</span><span class="hljs-params">( <span class="hljs-keyword">const</span> CBLAS_INT N, <span class="hljs-keyword">const</span> <span class="hljs-keyword">stdlib_complex64_t</span> ca, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *CX, <span class="hljs-keyword">const</span> CBLAS_INT strideX, <span class="hljs-keyword">const</span> CBLAS_INT offsetX, <span class="hljs-keyword">void</span> *CY, <span class="hljs-keyword">const</span> CBLAS_INT strideY, <span class="hljs-keyword">const</span> CBLAS_INT offsetY )</span></span>;
</code></pre></section><section class="notes"></section><section class="examples"><h3 id="examples-1">Examples</h3><pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/blas/base/caxpy.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/complex/float32/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">void</span> )</span> </span>{
    <span class="hljs-comment">// Create strided arrays of interleaved real and imaginary components...</span>
    <span class="hljs-keyword">float</span> cx[] = { <span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">5.0f</span>, <span class="hljs-number">6.0f</span>, <span class="hljs-number">7.0f</span>, <span class="hljs-number">8.0f</span> };
    <span class="hljs-keyword">float</span> cy[] = { <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-2.0f</span>, <span class="hljs-number">-3.0f</span>, <span class="hljs-number">-4.0f</span>, <span class="hljs-number">-5.0f</span>, <span class="hljs-number">-6.0f</span>, <span class="hljs-number">-7.0f</span>, <span class="hljs-number">-8.0f</span> };

    <span class="hljs-comment">// Create a complex scalar:</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">stdlib_complex64_t</span> ca = stdlib_complex64( <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span> );

    <span class="hljs-comment">// Specify the number of elements:</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4</span>;

    <span class="hljs-comment">// Specify strides...</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> strideX = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> strideY = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Scale values from `cx` by `ca` and adds the result to `cy`:</span>
    c_caxpy( N, ca, (<span class="hljs-keyword">void</span> *)cx, strideX, (<span class="hljs-keyword">void</span> *)cy, strideY );

    <span class="hljs-comment">// Print the result:</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &#x3C; N; i++ ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"cy[ %i ] = %f + %fj\n"</span>, i, cy[ i*<span class="hljs-number">2</span> ], cy[ (i*<span class="hljs-number">2</span>)+<span class="hljs-number">1</span> ] );
    }

    <span class="hljs-comment">// Scales values from `cx` by `ca` and adds the result to `cy` using alternative indexing semantics:</span>
    c_caxpy_ndarray( N, ca, (<span class="hljs-keyword">void</span> *)cx, -strideX, <span class="hljs-number">3</span>, (<span class="hljs-keyword">void</span> *)cy, -strideY, <span class="hljs-number">3</span> );

    <span class="hljs-comment">// Print the result:</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &#x3C; N; i++ ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"cy[ %i ] = %f + %fj\n"</span>, i, cy[ i*<span class="hljs-number">2</span> ], cy[ (i*<span class="hljs-number">2</span>)+<span class="hljs-number">1</span> ] );
    }
}
</code></pre></section></section><section class="related"></section><section class="links"></section>